<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/yomguithereal/mnemonist#readme">mnemonist (v0.12.0)</a>
</h1>
<h4>Curated collection of data structures for the JavaScript language.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist">module mnemonist</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree">
            function <span class="apidocSignatureSpan">mnemonist.</span>BKTree
            <span class="apidocSignatureSpan">(distance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BloomFilter">
            function <span class="apidocSignatureSpan">mnemonist.</span>BloomFilter
            <span class="apidocSignatureSpan">(capacityOrOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>FibonacciHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.GeneralizedSuffixArray">
            function <span class="apidocSignatureSpan">mnemonist.</span>GeneralizedSuffixArray
            <span class="apidocSignatureSpan">(strings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap">
            function <span class="apidocSignatureSpan">mnemonist.</span>Heap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index">
            function <span class="apidocSignatureSpan">mnemonist.</span>Index
            <span class="apidocSignatureSpan">(descriptor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex">
            function <span class="apidocSignatureSpan">mnemonist.</span>InvertedIndex
            <span class="apidocSignatureSpan">(descriptor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList">
            function <span class="apidocSignatureSpan">mnemonist.</span>LinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MaxFibonacciHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MaxFibonacciHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MaxHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MaxHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MinFibonacciHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MinFibonacciHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MinHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MinHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex">
            function <span class="apidocSignatureSpan">mnemonist.</span>MultiIndex
            <span class="apidocSignatureSpan">(descriptor, Container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MultiMap
            <span class="apidocSignatureSpan">(Container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet">
            function <span class="apidocSignatureSpan">mnemonist.</span>MultiSet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue">
            function <span class="apidocSignatureSpan">mnemonist.</span>Queue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack">
            function <span class="apidocSignatureSpan">mnemonist.</span>Stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SuffixArray">
            function <span class="apidocSignatureSpan">mnemonist.</span>SuffixArray
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SymSpell">
            function <span class="apidocSignatureSpan">mnemonist.</span>SymSpell
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie">
            function <span class="apidocSignatureSpan">mnemonist.</span>Trie
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.VPTree">
            function <span class="apidocSignatureSpan">mnemonist.</span>VPTree
            <span class="apidocSignatureSpan">(distance, items)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>BKTree.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>BloomFilter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>FibonacciHeap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>GeneralizedSuffixArray.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>Heap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>Index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>InvertedIndex.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>LinkedList.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>MultiIndex.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>MultiMap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>MultiSet.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>Queue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>Set</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>Stack.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>SuffixArray.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>SymSpell.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>Trie.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>VPTree.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mnemonist.</span>comparators</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.BKTree">module mnemonist.BKTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree.BKTree">
            function <span class="apidocSignatureSpan">mnemonist.</span>BKTree
            <span class="apidocSignatureSpan">(distance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree.from">
            function <span class="apidocSignatureSpan">mnemonist.BKTree.</span>from
            <span class="apidocSignatureSpan">(iterable, distance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.BKTree.prototype">module mnemonist.BKTree.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>add
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree.prototype.search">
            function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>search
            <span class="apidocSignatureSpan">(n, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BKTree.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.BloomFilter">module mnemonist.BloomFilter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BloomFilter.BloomFilter">
            function <span class="apidocSignatureSpan">mnemonist.</span>BloomFilter
            <span class="apidocSignatureSpan">(capacityOrOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BloomFilter.from">
            function <span class="apidocSignatureSpan">mnemonist.BloomFilter.</span>from
            <span class="apidocSignatureSpan">(iterable, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.BloomFilter.prototype">module mnemonist.BloomFilter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BloomFilter.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>add
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BloomFilter.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BloomFilter.prototype.test">
            function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>test
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.BloomFilter.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.FibonacciHeap">module mnemonist.FibonacciHeap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.FibonacciHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>FibonacciHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.MaxFibonacciHeap">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.</span>MaxFibonacciHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.MinFibonacciHeap">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.</span>MinFibonacciHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.from">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.</span>from
            <span class="apidocSignatureSpan">(iterable, comparator)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.FibonacciHeap.prototype">module mnemonist.FibonacciHeap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.prototype.peek">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.prototype.pop">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.FibonacciHeap.prototype.push">
            function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>push
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.GeneralizedSuffixArray">module mnemonist.GeneralizedSuffixArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.GeneralizedSuffixArray.GeneralizedSuffixArray">
            function <span class="apidocSignatureSpan">mnemonist.</span>GeneralizedSuffixArray
            <span class="apidocSignatureSpan">(strings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.GeneralizedSuffixArray.prototype">module mnemonist.GeneralizedSuffixArray.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.longestCommonSubsequence">
            function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>longestCommonSubsequence
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.toString">
            function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Heap">module mnemonist.Heap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.Heap">
            function <span class="apidocSignatureSpan">mnemonist.</span>Heap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.MaxHeap">
            function <span class="apidocSignatureSpan">mnemonist.Heap.</span>MaxHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.MinHeap">
            function <span class="apidocSignatureSpan">mnemonist.Heap.</span>MinHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.from">
            function <span class="apidocSignatureSpan">mnemonist.Heap.</span>from
            <span class="apidocSignatureSpan">(iterable, comparator)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Heap.prototype">module mnemonist.Heap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.prototype.peek">
            function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.prototype.pop">
            function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Heap.prototype.push">
            function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>push
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Index">module mnemonist.Index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.Index">
            function <span class="apidocSignatureSpan">mnemonist.</span>Index
            <span class="apidocSignatureSpan">(descriptor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.from">
            function <span class="apidocSignatureSpan">mnemonist.Index.</span>from
            <span class="apidocSignatureSpan">(iterable, descriptor, useSet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Index.prototype">module mnemonist.Index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>add
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.prototype.get">
            function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.prototype.set">
            function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>set
            <span class="apidocSignatureSpan">(key, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Index.prototype.values">
            function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.InvertedIndex">module mnemonist.InvertedIndex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.InvertedIndex">
            function <span class="apidocSignatureSpan">mnemonist.</span>InvertedIndex
            <span class="apidocSignatureSpan">(descriptor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.from">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.</span>from
            <span class="apidocSignatureSpan">(iterable, descriptor)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.InvertedIndex.prototype">module mnemonist.InvertedIndex.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>add
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.andQuery">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>andQuery
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.documents">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>documents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.orQuery">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>orQuery
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.query">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>query
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.InvertedIndex.prototype.tokens">
            function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>tokens
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.LinkedList">module mnemonist.LinkedList</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.LinkedList">
            function <span class="apidocSignatureSpan">mnemonist.</span>LinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.from">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.</span>from
            <span class="apidocSignatureSpan">(iterable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.LinkedList.prototype">module mnemonist.LinkedList.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.entries">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>entries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.first">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.last">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.peek">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.push">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>push
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.shift">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.toArray">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.toString">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.unshift">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>unshift
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.LinkedList.prototype.values">
            function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MaxFibonacciHeap">module mnemonist.MaxFibonacciHeap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MaxFibonacciHeap.MaxFibonacciHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MaxFibonacciHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MaxFibonacciHeap.from">
            function <span class="apidocSignatureSpan">mnemonist.MaxFibonacciHeap.</span>from
            <span class="apidocSignatureSpan">(iterable, comparator)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MaxHeap">module mnemonist.MaxHeap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MaxHeap.MaxHeap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MaxHeap
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MaxHeap.from">
            function <span class="apidocSignatureSpan">mnemonist.MaxHeap.</span>from
            <span class="apidocSignatureSpan">(iterable, comparator)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MultiIndex">module mnemonist.MultiIndex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.MultiIndex">
            function <span class="apidocSignatureSpan">mnemonist.</span>MultiIndex
            <span class="apidocSignatureSpan">(descriptor, Container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.from">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.</span>from
            <span class="apidocSignatureSpan">(iterable, descriptor, Container, useSet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MultiIndex.prototype">module mnemonist.MultiIndex.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>add
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.prototype.get">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.prototype.set">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>set
            <span class="apidocSignatureSpan">(key, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiIndex.prototype.values">
            function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MultiMap">module mnemonist.MultiMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.MultiMap">
            function <span class="apidocSignatureSpan">mnemonist.</span>MultiMap
            <span class="apidocSignatureSpan">(Container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.from">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.</span>from
            <span class="apidocSignatureSpan">(iterable, Container)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MultiMap.prototype">module mnemonist.MultiMap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.associations">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>associations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.containers">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>containers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.delete">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>delete
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.entries">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>entries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.get">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.has">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>has
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.keys">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.set">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>set
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiMap.prototype.values">
            function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MultiSet">module mnemonist.MultiSet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.MultiSet">
            function <span class="apidocSignatureSpan">mnemonist.</span>MultiSet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.from">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.</span>from
            <span class="apidocSignatureSpan">(iterable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.MultiSet.prototype">module mnemonist.MultiSet.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>add
            <span class="apidocSignatureSpan">(item, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.delete">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>delete
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.has">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>has
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.multiplicities">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>multiplicities
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.multiplicity">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>multiplicity
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.remove">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>remove
            <span class="apidocSignatureSpan">(item, count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.MultiSet.prototype.values">
            function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Queue">module mnemonist.Queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.Queue">
            function <span class="apidocSignatureSpan">mnemonist.</span>Queue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.from">
            function <span class="apidocSignatureSpan">mnemonist.Queue.</span>from
            <span class="apidocSignatureSpan">(iterable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Queue.prototype">module mnemonist.Queue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.dequeue">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>dequeue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.enqueue">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.entries">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>entries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.peek">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.toArray">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.toString">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Queue.prototype.values">
            function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Set">module mnemonist.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.add">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>add
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.difference">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>difference
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.disjunct">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>disjunct
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.intersect">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>intersect
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.intersection">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>intersection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.isSubset">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>isSubset
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.isSuperset">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>isSuperset
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.subtract">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>subtract
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.symmetricDifference">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>symmetricDifference
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Set.union">
            function <span class="apidocSignatureSpan">mnemonist.Set.</span>union
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Stack">module mnemonist.Stack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.Stack">
            function <span class="apidocSignatureSpan">mnemonist.</span>Stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.from">
            function <span class="apidocSignatureSpan">mnemonist.Stack.</span>from
            <span class="apidocSignatureSpan">(iterable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Stack.prototype">module mnemonist.Stack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.entries">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>entries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.forEach">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.peek">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.pop">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.push">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>push
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.toArray">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.toString">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Stack.prototype.values">
            function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.SuffixArray">module mnemonist.SuffixArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SuffixArray.SuffixArray">
            function <span class="apidocSignatureSpan">mnemonist.</span>SuffixArray
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SuffixArray.GeneralizedSuffixArray">
            function <span class="apidocSignatureSpan">mnemonist.SuffixArray.</span>GeneralizedSuffixArray
            <span class="apidocSignatureSpan">(strings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.SuffixArray.prototype">module mnemonist.SuffixArray.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SuffixArray.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.SuffixArray.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SuffixArray.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.SuffixArray.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SuffixArray.prototype.toString">
            function <span class="apidocSignatureSpan">mnemonist.SuffixArray.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.SymSpell">module mnemonist.SymSpell</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SymSpell.SymSpell">
            function <span class="apidocSignatureSpan">mnemonist.</span>SymSpell
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SymSpell.from">
            function <span class="apidocSignatureSpan">mnemonist.SymSpell.</span>from
            <span class="apidocSignatureSpan">(iterable, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.SymSpell.prototype">module mnemonist.SymSpell.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SymSpell.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>add
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SymSpell.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SymSpell.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.SymSpell.prototype.search">
            function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>search
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Trie">module mnemonist.Trie</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.Trie">
            function <span class="apidocSignatureSpan">mnemonist.</span>Trie
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.from">
            function <span class="apidocSignatureSpan">mnemonist.Trie.</span>from
            <span class="apidocSignatureSpan">(iterable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.Trie.prototype">module mnemonist.Trie.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.add">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>add
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.clear">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.delete">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>delete
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.get">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>get
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.has">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>has
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.longestPrefix">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>longestPrefix
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.Trie.prototype.toJSON">
            function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.VPTree">module mnemonist.VPTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.VPTree.VPTree">
            function <span class="apidocSignatureSpan">mnemonist.</span>VPTree
            <span class="apidocSignatureSpan">(distance, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.VPTree.from">
            function <span class="apidocSignatureSpan">mnemonist.VPTree.</span>from
            <span class="apidocSignatureSpan">(iterable, distance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.VPTree.prototype">module mnemonist.VPTree.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.VPTree.prototype.inspect">
            function <span class="apidocSignatureSpan">mnemonist.VPTree.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.VPTree.prototype.nearestNeighbors">
            function <span class="apidocSignatureSpan">mnemonist.VPTree.prototype.</span>nearestNeighbors
            <span class="apidocSignatureSpan">(k, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.VPTree.prototype.neighbors">
            function <span class="apidocSignatureSpan">mnemonist.VPTree.prototype.</span>neighbors
            <span class="apidocSignatureSpan">(radius, query)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mnemonist.comparators">module mnemonist.comparators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.comparators.DEFAULT_COMPARATOR">
            function <span class="apidocSignatureSpan">mnemonist.comparators.</span>DEFAULT_COMPARATOR
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mnemonist.comparators.reverseComparator">
            function <span class="apidocSignatureSpan">mnemonist.comparators.</span>reverseComparator
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist" id="apidoc.module.mnemonist">module mnemonist</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.BKTree" id="apidoc.element.mnemonist.BKTree">
        function <span class="apidocSignatureSpan">mnemonist.</span>BKTree
        <span class="apidocSignatureSpan">(distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BKTree(distance) {

  if (typeof distance !== 'function')
    throw new Error('mnemonist/BKTree.constructor: given `distance` should be a function.');

  this.distance = distance;
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BloomFilter" id="apidoc.element.mnemonist.BloomFilter">
        function <span class="apidocSignatureSpan">mnemonist.</span>BloomFilter
        <span class="apidocSignatureSpan">(capacityOrOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BloomFilter(capacityOrOptions) {
  var options = {};

  if (!capacityOrOptions)
    throw new Error('mnemonist/BloomFilter.constructor: a BloomFilter must be created with a capacity.');

  if (typeof capacityOrOptions === 'object')
    options = capacityOrOptions;
  else
    options.capacity = capacityOrOptions;

  // Handling capacity
  if (typeof options.capacity !== 'number' || options.capacity &lt;= 0)
    throw new Error('mnemonist/BloomFilter.constructor: `capacity` option should be a positive integer.');

  this.capacity = options.capacity;

  // Handling error rate
  this.errorRate = options.errorRate || DEFAULTS.errorRate;

  if (typeof this.errorRate !== 'number' || options.errorRate &lt;= 0)
    throw new Error('mnemonist/BloomFilter.constructor: `errorRate` option should be a positive float.');

  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap" id="apidoc.element.mnemonist.FibonacciHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>FibonacciHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.GeneralizedSuffixArray" id="apidoc.element.mnemonist.GeneralizedSuffixArray">
        function <span class="apidocSignatureSpan">mnemonist.</span>GeneralizedSuffixArray
        <span class="apidocSignatureSpan">(strings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GeneralizedSuffixArray(strings) {

  // Properties
  this.hasArbitrarySequence = typeof strings[0] !== 'string';
  this.size = strings.length;

  if (this.hasArbitrarySequence) {
    this.text = [];

    for (var i = 0, l = this.size; i &lt; l; i++) {
      this.text.push.apply(this.text, strings[i]);

      if (i &lt; l - 1)
        this.text.push(SEPARATOR);
    }
  }
  else {
    this.text = strings.join(SEPARATOR);
  }

  this.firstLength = strings[0].length;
  this.length = this.text.length;

  // Building the array
  this.array = build(convert(this.text), this.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap" id="apidoc.element.mnemonist.Heap">
        function <span class="apidocSignatureSpan">mnemonist.</span>Heap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index" id="apidoc.element.mnemonist.Index">
        function <span class="apidocSignatureSpan">mnemonist.</span>Index
        <span class="apidocSignatureSpan">(descriptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(descriptor) {
  this.items = new Map();
  this.clear();

  if (Array.isArray(descriptor)) {
    this.writeHashFunction = descriptor[0];
    this.readHashFunction = descriptor[1];
  }
  else {
    this.writeHashFunction = descriptor;
    this.readHashFunction = descriptor;
  }

  if (!this.writeHashFunction)
    this.writeHashFunction = identity;
  if (!this.readHashFunction)
    this.readHashFunction = identity;

  if (typeof this.writeHashFunction !== 'function')
    throw new Error('mnemonist/Index.constructor: invalid hash function given.');

  if (typeof this.readHashFunction !== 'function')
    throw new Error('mnemonist/Index.constructor: invalid hash function given.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex" id="apidoc.element.mnemonist.InvertedIndex">
        function <span class="apidocSignatureSpan">mnemonist.</span>InvertedIndex
        <span class="apidocSignatureSpan">(descriptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InvertedIndex(descriptor) {
  this.clear();

  if (Array.isArray(descriptor)) {
    this.documentTokenizer = descriptor[0];
    this.queryTokenizer = descriptor[1];
  }
  else {
    this.documentTokenizer = descriptor;
    this.queryTokenizer = descriptor;
  }

  if (!this.documentTokenizer)
    this.documentTokenizer = identity;
  if (!this.queryTokenizer)
    this.queryTokenizer = identity;

  if (typeof this.documentTokenizer !== 'function')
    throw new Error('mnemonist/InvertedIndex.constructor: document tokenizer is not a function.');

  if (typeof this.queryTokenizer !== 'function')
    throw new Error('mnemonist/InvertedIndex.constructor: query tokenizer is not a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList" id="apidoc.element.mnemonist.LinkedList">
        function <span class="apidocSignatureSpan">mnemonist.</span>LinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkedList() {
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MaxFibonacciHeap" id="apidoc.element.mnemonist.MaxFibonacciHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MaxFibonacciHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxFibonacciHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MaxHeap" id="apidoc.element.mnemonist.MaxHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MaxHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MinFibonacciHeap" id="apidoc.element.mnemonist.MinFibonacciHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MinFibonacciHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MinHeap" id="apidoc.element.mnemonist.MinHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MinHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex" id="apidoc.element.mnemonist.MultiIndex">
        function <span class="apidocSignatureSpan">mnemonist.</span>MultiIndex
        <span class="apidocSignatureSpan">(descriptor, Container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiIndex(descriptor, Container) {
  this.items = new MultiMap(Container);
  this.clear();

  if (Array.isArray(descriptor)) {
    this.writeHashFunction = descriptor[0];
    this.readHashFunction = descriptor[1];
  }
  else {
    this.writeHashFunction = descriptor;
    this.readHashFunction = descriptor;
  }

  if (!this.writeHashFunction)
    this.writeHashFunction = identity;
  if (!this.readHashFunction)
    this.readHashFunction = identity;

  if (typeof this.writeHashFunction !== 'function')
    throw new Error('mnemonist/MultiIndex.constructor: invalid hash function given.');

  if (typeof this.readHashFunction !== 'function')
    throw new Error('mnemonist/MultiIndex.constructor: invalid hash function given.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap" id="apidoc.element.mnemonist.MultiMap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MultiMap
        <span class="apidocSignatureSpan">(Container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiMap(Container) {

  this.Container = Container || Array;
  this.items = new Map();
  this.clear();

  Object.defineProperty(this.items, 'constructor', {
    value: MultiMap,
    enumerable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet" id="apidoc.element.mnemonist.MultiSet">
        function <span class="apidocSignatureSpan">mnemonist.</span>MultiSet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiSet() {
  this.items = new Map();

  Object.defineProperty(this.items, 'constructor', {
    value: MultiSet,
    enumerable: false
  });

  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue" id="apidoc.element.mnemonist.Queue">
        function <span class="apidocSignatureSpan">mnemonist.</span>Queue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue() {
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack" id="apidoc.element.mnemonist.Stack">
        function <span class="apidocSignatureSpan">mnemonist.</span>Stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack() {
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SuffixArray" id="apidoc.element.mnemonist.SuffixArray">
        function <span class="apidocSignatureSpan">mnemonist.</span>SuffixArray
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SuffixArray(string) {

  // Properties
  this.hasArbitrarySequence = typeof string !== 'string';
  this.string = string;
  this.length = string.length;

  // Building the array
  this.array = build(convert(string), this.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SymSpell" id="apidoc.element.mnemonist.SymSpell">
        function <span class="apidocSignatureSpan">mnemonist.</span>SymSpell
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymSpell(options) {
  options = options || {};

  this.clear();

  // Properties
  this.maxDistance = typeof options.maxDistance === 'number' ?
    options.maxDistance :
    DEFAULT_MAX_DISTANCE;
  this.verbosity = typeof options.verbosity === 'number' ?
    options.verbosity :
    DEFAULT_VERBOSITY;

  // Sanity checks
  if (typeof this.maxDistance !== 'number' || this.maxDistance &lt;= 0)
    throw Error('mnemonist/SymSpell.constructor: invalid `maxDistance` option. Should be a integer greater than 0.');

  if (!VERBOSITY.has(this.verbosity))
    throw Error('mnemonist/SymSpell.constructor: invalid `verbosity` option. Should be either 0, 1 or 2.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie" id="apidoc.element.mnemonist.Trie">
        function <span class="apidocSignatureSpan">mnemonist.</span>Trie
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trie() {
  this.clear();
  this.end = SENTINEL;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.VPTree" id="apidoc.element.mnemonist.VPTree">
        function <span class="apidocSignatureSpan">mnemonist.</span>VPTree
        <span class="apidocSignatureSpan">(distance, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VPTree(distance, items) {
  if (typeof distance !== 'function')
    throw new Error('mnemonist/VPTree.constructor: given `distance` must be a function.');

  if (!items)
    throw new Error('mnemonist/VPTree.constructor: you must provide items to the tree. A VPTree cannot be updated after its creation
.');

  // Properties
  this.distance = distance;
  this.items = [];

  var indexes = [],
      self = this,
      i = 0;

  iterateOver(items, function(value) {
    self.items.push(value);
    indexes.push(i++);
  });

  // Creating the binary tree
  this.size = indexes.length;
  this.data = createBinaryTree(distance, this.items, indexes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.BKTree" id="apidoc.module.mnemonist.BKTree">module mnemonist.BKTree</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.BKTree.BKTree" id="apidoc.element.mnemonist.BKTree.BKTree">
        function <span class="apidocSignatureSpan">mnemonist.</span>BKTree
        <span class="apidocSignatureSpan">(distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BKTree(distance) {

  if (typeof distance !== 'function')
    throw new Error('mnemonist/BKTree.constructor: given `distance` should be a function.');

  this.distance = distance;
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BKTree.from" id="apidoc.element.mnemonist.BKTree.from">
        function <span class="apidocSignatureSpan">mnemonist.BKTree.</span>from
        <span class="apidocSignatureSpan">(iterable, distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, distance) {
  var tree = new BKTree(distance);

  iterateOver(iterable, function(value) {
    tree.add(value);
  });

  return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.BKTree.prototype" id="apidoc.module.mnemonist.BKTree.prototype">module mnemonist.BKTree.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.BKTree.prototype.add" id="apidoc.element.mnemonist.BKTree.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>add
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (item) {

  // Initializing the tree with the first given word
  if (!this.root) {
    this.root = {
      item: item,
      children: {}
    };

    this.size++;
    return this;
  }

  var node = this.root,
      d;

  while (true) {
    d = this.distance(item, node.item);

    if (!node.children[d])
      break;

    node = node.children[d];
  }

  node.children[d] = {
    item: item,
    children: {}
  };

  this.size++;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BKTree.prototype.clear" id="apidoc.element.mnemonist.BKTree.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.size = 0;
  this.root = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BKTree.prototype.inspect" id="apidoc.element.mnemonist.BKTree.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = [],
      stack = [this.root],
      node,
      d;

  while (stack.length) {
    node = stack.pop();

    if (!node)
      continue;

    array.push(node.item);

    for (d in node.children)
      stack.push(node.children[d]);
  }

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: BKTree,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BKTree.prototype.search" id="apidoc.element.mnemonist.BKTree.prototype.search">
        function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>search
        <span class="apidocSignatureSpan">(n, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (n, query) {
  if (!this.root)
    return [];

  var found = [],
      stack = [this.root],
      node,
      child,
      d,
      i,
      l;

  while (stack.length) {
    node = stack.pop();
    d = this.distance(query, node.item);

    if (d &lt;= n)
      found.push({item: node.item, distance: d});

    for (i = d - n, l = d + n + 1; i &lt; l; i++) {
      child = node.children[i];

      if (child)
        stack.push(child);
    }
  }

  return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BKTree.prototype.toJSON" id="apidoc.element.mnemonist.BKTree.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.BKTree.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.BloomFilter" id="apidoc.module.mnemonist.BloomFilter">module mnemonist.BloomFilter</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.BloomFilter.BloomFilter" id="apidoc.element.mnemonist.BloomFilter.BloomFilter">
        function <span class="apidocSignatureSpan">mnemonist.</span>BloomFilter
        <span class="apidocSignatureSpan">(capacityOrOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BloomFilter(capacityOrOptions) {
  var options = {};

  if (!capacityOrOptions)
    throw new Error('mnemonist/BloomFilter.constructor: a BloomFilter must be created with a capacity.');

  if (typeof capacityOrOptions === 'object')
    options = capacityOrOptions;
  else
    options.capacity = capacityOrOptions;

  // Handling capacity
  if (typeof options.capacity !== 'number' || options.capacity &lt;= 0)
    throw new Error('mnemonist/BloomFilter.constructor: `capacity` option should be a positive integer.');

  this.capacity = options.capacity;

  // Handling error rate
  this.errorRate = options.errorRate || DEFAULTS.errorRate;

  if (typeof this.errorRate !== 'number' || options.errorRate &lt;= 0)
    throw new Error('mnemonist/BloomFilter.constructor: `errorRate` option should be a positive float.');

  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BloomFilter.from" id="apidoc.element.mnemonist.BloomFilter.from">
        function <span class="apidocSignatureSpan">mnemonist.BloomFilter.</span>from
        <span class="apidocSignatureSpan">(iterable, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, options) {
  if (!options) {
    options = iterable.length || iterable.size;

    if (typeof options !== 'number')
      throw new Error('BloomFilter.from: could not infer the filter\'s capacity. Try passing it as second argument.');
  }

  var filter = new BloomFilter(options);

  iterateOver(iterable, function(value) {
    filter.add(value);
  });

  return filter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.BloomFilter.prototype" id="apidoc.module.mnemonist.BloomFilter.prototype">module mnemonist.BloomFilter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.BloomFilter.prototype.add" id="apidoc.element.mnemonist.BloomFilter.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>add
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (string) {

  // Converting the string to a byte array
  var array = stringToByteArray(string);

  // Applying the n hash functions
  for (var i = 0, l = this.hashFunctions; i &lt; l; i++) {
    var index = hashArray(this.data.length, i, array),
        position = (1 &lt;&lt; (7 &amp; index));

    this.data[index &gt;&gt; 3] |= position;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BloomFilter.prototype.clear" id="apidoc.element.mnemonist.BloomFilter.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Optimizing number of bits &amp; number of hash functions
  var bits = -1 / LN2_SQUARED * this.capacity * Math.log(this.errorRate),
      length = (bits / 8) | 0;

  this.hashFunctions = (length * 8 / this.capacity * Math.LN2) | 0;

  // Creating the data array
  this.data = new Uint8Array(length);

  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BloomFilter.prototype.test" id="apidoc.element.mnemonist.BloomFilter.prototype.test">
        function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>test
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (string) {

  // Converting the string to a byte array
  var array = stringToByteArray(string);

  // Applying the n hash functions
  for (var i = 0, l = this.hashFunctions; i &lt; l; i++) {
    var index = hashArray(this.data.length, i, array);

    if (!(this.data[index &gt;&gt; 3] &amp; (1 &lt;&lt; (7 &amp; index))))
      return false;
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.BloomFilter.prototype.toJSON" id="apidoc.element.mnemonist.BloomFilter.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.BloomFilter.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.FibonacciHeap" id="apidoc.module.mnemonist.FibonacciHeap">module mnemonist.FibonacciHeap</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.FibonacciHeap" id="apidoc.element.mnemonist.FibonacciHeap.FibonacciHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>FibonacciHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.MaxFibonacciHeap" id="apidoc.element.mnemonist.FibonacciHeap.MaxFibonacciHeap">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.</span>MaxFibonacciHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxFibonacciHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.MinFibonacciHeap" id="apidoc.element.mnemonist.FibonacciHeap.MinFibonacciHeap">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.</span>MinFibonacciHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.from" id="apidoc.element.mnemonist.FibonacciHeap.from">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.</span>from
        <span class="apidocSignatureSpan">(iterable, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, comparator) {
  var heap = new FibonacciHeap(comparator);

  iterateOver(iterable, function(value) {
    heap.push(value);
  });

  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.FibonacciHeap.prototype" id="apidoc.module.mnemonist.FibonacciHeap.prototype">module mnemonist.FibonacciHeap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.prototype.clear" id="apidoc.element.mnemonist.FibonacciHeap.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.root = null;
  this.min = null;
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.prototype.inspect" id="apidoc.element.mnemonist.FibonacciHeap.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var proxy = {
    size: this.size
  };

  if (this.min &amp;&amp; 'item' in this.min)
    proxy.top = this.min.item;

  // Trick so that node displays the name of the constructor
  Object.defineProperty(proxy, 'constructor', {
    value: FibonacciHeap,
    enumerable: false
  });

  return proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.prototype.peek" id="apidoc.element.mnemonist.FibonacciHeap.prototype.peek">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.min ? this.min.item : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.prototype.pop" id="apidoc.element.mnemonist.FibonacciHeap.prototype.pop">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  if (!this.size)
    return undefined;

  var z = this.min;

  if (z.child) {
    var nodes = iterate(z.child),
        node,
        i,
        l;

    for (i = 0, l = nodes.length; i &lt; l; i++) {
      node = nodes[i];

      mergeWithRoot(this, node);
      delete node.parent;
    }
  }

  removeFromRoot(this, z);

  if (z === z.right) {
    this.min = null;
    this.root = null;
  }
  else {
    this.min = z.right;
    consolidate(this);
  }

  this.size--;

  return z.item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.FibonacciHeap.prototype.push" id="apidoc.element.mnemonist.FibonacciHeap.prototype.push">
        function <span class="apidocSignatureSpan">mnemonist.FibonacciHeap.prototype.</span>push
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (item) {
  var node = createNode(item);
  node.left = node;
  node.right = node;
  mergeWithRoot(this, node);

  if (!this.min || this.comparator(node.item, this.min.item) &lt;= 0)
    this.min = node;

  return ++this.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.GeneralizedSuffixArray" id="apidoc.module.mnemonist.GeneralizedSuffixArray">module mnemonist.GeneralizedSuffixArray</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.GeneralizedSuffixArray.GeneralizedSuffixArray" id="apidoc.element.mnemonist.GeneralizedSuffixArray.GeneralizedSuffixArray">
        function <span class="apidocSignatureSpan">mnemonist.</span>GeneralizedSuffixArray
        <span class="apidocSignatureSpan">(strings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GeneralizedSuffixArray(strings) {

  // Properties
  this.hasArbitrarySequence = typeof strings[0] !== 'string';
  this.size = strings.length;

  if (this.hasArbitrarySequence) {
    this.text = [];

    for (var i = 0, l = this.size; i &lt; l; i++) {
      this.text.push.apply(this.text, strings[i]);

      if (i &lt; l - 1)
        this.text.push(SEPARATOR);
    }
  }
  else {
    this.text = strings.join(SEPARATOR);
  }

  this.firstLength = strings[0].length;
  this.length = this.text.length;

  // Building the array
  this.array = build(convert(this.text), this.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.GeneralizedSuffixArray.prototype" id="apidoc.module.mnemonist.GeneralizedSuffixArray.prototype">module mnemonist.GeneralizedSuffixArray.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.inspect" id="apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = new Array(this.length);

  for (var i = 0; i &lt; this.length; i++)
    array[i] = this.text.slice(this.array[i]);

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: GeneralizedSuffixArray,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.longestCommonSubsequence" id="apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.longestCommonSubsequence">
        function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>longestCommonSubsequence
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">longestCommonSubsequence = function () {
  var lcs = this.hasArbitrarySequence ? [] : '',
      lcp,
      i,
      j,
      s,
      t;

  for (i = 1; i &lt; this.length; i++) {
    s = this.array[i];
    t = this.array[i - 1];

    if (s &lt; this.firstLength &amp;&amp;
        t &lt; this.firstLength)
      continue;

    if (s &gt; this.firstLength &amp;&amp;
        t &gt; this.firstLength)
      continue;

    lcp = Math.min(this.length - s, this.length - t);

    for (j = 0; j &lt; lcp; j++) {
      if (this.text[s + j] !== this.text[t + j]) {
        lcp = j;
        break;
      }
    }

    if (lcp &gt; lcs.length)
      lcs = this.text.slice(s, s + lcp);
  }

  return lcs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.toJSON" id="apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.toString" id="apidoc.element.mnemonist.GeneralizedSuffixArray.prototype.toString">
        function <span class="apidocSignatureSpan">mnemonist.GeneralizedSuffixArray.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.array.join(',');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Heap" id="apidoc.module.mnemonist.Heap">module mnemonist.Heap</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Heap.Heap" id="apidoc.element.mnemonist.Heap.Heap">
        function <span class="apidocSignatureSpan">mnemonist.</span>Heap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap.MaxHeap" id="apidoc.element.mnemonist.Heap.MaxHeap">
        function <span class="apidocSignatureSpan">mnemonist.Heap.</span>MaxHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap.MinHeap" id="apidoc.element.mnemonist.Heap.MinHeap">
        function <span class="apidocSignatureSpan">mnemonist.Heap.</span>MinHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap.from" id="apidoc.element.mnemonist.Heap.from">
        function <span class="apidocSignatureSpan">mnemonist.Heap.</span>from
        <span class="apidocSignatureSpan">(iterable, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, comparator) {
  var heap = new Heap(comparator);

  iterateOver(iterable, function(value) {
    heap.push(value);
  });

  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Heap.prototype" id="apidoc.module.mnemonist.Heap.prototype">module mnemonist.Heap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Heap.prototype.clear" id="apidoc.element.mnemonist.Heap.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.items = [];
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap.prototype.inspect" id="apidoc.element.mnemonist.Heap.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var proxy = {
    size: this.size
  };

  if (this.items.length)
    proxy.top = this.items[0];

  // Trick so that node displays the name of the constructor
  Object.defineProperty(proxy, 'constructor', {
    value: Heap,
    enumerable: false
  });

  return proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap.prototype.peek" id="apidoc.element.mnemonist.Heap.prototype.peek">
        function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.items[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap.prototype.pop" id="apidoc.element.mnemonist.Heap.prototype.pop">
        function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  if (!this.size)
    return undefined;

  var item = this.items[0],
      last = this.items.pop();

  this.size--;

  if (this.size) {
    this.items[0] = last;
    sinkDown(this.comparator, this.items, 0);
  }

  return item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Heap.prototype.push" id="apidoc.element.mnemonist.Heap.prototype.push">
        function <span class="apidocSignatureSpan">mnemonist.Heap.prototype.</span>push
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (item) {
  this.items.push(item);
  bubbleUp(this.comparator, this.items, this.size);
  return ++this.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Index" id="apidoc.module.mnemonist.Index">module mnemonist.Index</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Index.Index" id="apidoc.element.mnemonist.Index.Index">
        function <span class="apidocSignatureSpan">mnemonist.</span>Index
        <span class="apidocSignatureSpan">(descriptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(descriptor) {
  this.items = new Map();
  this.clear();

  if (Array.isArray(descriptor)) {
    this.writeHashFunction = descriptor[0];
    this.readHashFunction = descriptor[1];
  }
  else {
    this.writeHashFunction = descriptor;
    this.readHashFunction = descriptor;
  }

  if (!this.writeHashFunction)
    this.writeHashFunction = identity;
  if (!this.readHashFunction)
    this.readHashFunction = identity;

  if (typeof this.writeHashFunction !== 'function')
    throw new Error('mnemonist/Index.constructor: invalid hash function given.');

  if (typeof this.readHashFunction !== 'function')
    throw new Error('mnemonist/Index.constructor: invalid hash function given.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index.from" id="apidoc.element.mnemonist.Index.from">
        function <span class="apidocSignatureSpan">mnemonist.Index.</span>from
        <span class="apidocSignatureSpan">(iterable, descriptor, useSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, descriptor, useSet) {
  var index = new Index(descriptor);

  iterateOver(iterable, function(value, key) {
    if (useSet)
      index.set(key, value);
    else
      index.add(value);
  });

  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Index.prototype" id="apidoc.module.mnemonist.Index.prototype">module mnemonist.Index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Index.prototype.add" id="apidoc.element.mnemonist.Index.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>add
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (item) {
  var key = this.writeHashFunction(item);

  this.items.set(key, item);
  this.size = this.items.size;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index.prototype.clear" id="apidoc.element.mnemonist.Index.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  this.items.clear();

  // Properties
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index.prototype.forEach" id="apidoc.element.mnemonist.Index.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  scope = arguments.length &gt; 1 ? scope : this;

  this.items.forEach(function(value) {
    callback.call(scope, value, value);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index.prototype.get" id="apidoc.element.mnemonist.Index.prototype.get">
        function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  key = this.readHashFunction(key);

  return this.items.get(key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param  {any} key - Key to use.
* @return {Index}
*/
Index.prototype.get = function(key) {
 key = this.readHashFunction(key);

 return this.items.<span class="apidocCodeKeywordSpan">get</span>(key);
};

/**
* Method used to iterate over each of the index's values.
*
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index.prototype.inspect" id="apidoc.element.mnemonist.Index.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = Array.from(this.items.values());

  Object.defineProperty(array, 'constructor', {
    value: Index,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index.prototype.set" id="apidoc.element.mnemonist.Index.prototype.set">
        function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>set
        <span class="apidocSignatureSpan">(key, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, item) {
  key = this.writeHashFunction(key);

  this.items.set(key, item);
  this.size = this.items.size;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param  {any} item - Item to add.
* @return {Index}
*/
Index.prototype.add = function(item) {
 var key = this.writeHashFunction(item);

 this.items.<span class="apidocCodeKeywordSpan">set</span>(key, item);
 this.size = this.items.size;

 return this;
};

/**
* Method used to set an item in the index using the given key.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Index.prototype.values" id="apidoc.element.mnemonist.Index.prototype.values">
        function <span class="apidocSignatureSpan">mnemonist.Index.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  var iterator = this.items.values();

  Object.defineProperty(iterator, 'constructor', {
    value: IndexIterator,
    enumerable: false
  });

  return iterator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning an iterator over the index's values.
 *
 * @return {IndexIterator}
 */
Index.prototype.values = function() {
var iterator = this.items.<span class="apidocCodeKeywordSpan">values</span>();

Object.defineProperty(iterator, 'constructor', {
  value: IndexIterator,
  enumerable: false
});

return iterator;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.InvertedIndex" id="apidoc.module.mnemonist.InvertedIndex">module mnemonist.InvertedIndex</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.InvertedIndex" id="apidoc.element.mnemonist.InvertedIndex.InvertedIndex">
        function <span class="apidocSignatureSpan">mnemonist.</span>InvertedIndex
        <span class="apidocSignatureSpan">(descriptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InvertedIndex(descriptor) {
  this.clear();

  if (Array.isArray(descriptor)) {
    this.documentTokenizer = descriptor[0];
    this.queryTokenizer = descriptor[1];
  }
  else {
    this.documentTokenizer = descriptor;
    this.queryTokenizer = descriptor;
  }

  if (!this.documentTokenizer)
    this.documentTokenizer = identity;
  if (!this.queryTokenizer)
    this.queryTokenizer = identity;

  if (typeof this.documentTokenizer !== 'function')
    throw new Error('mnemonist/InvertedIndex.constructor: document tokenizer is not a function.');

  if (typeof this.queryTokenizer !== 'function')
    throw new Error('mnemonist/InvertedIndex.constructor: query tokenizer is not a function.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.from" id="apidoc.element.mnemonist.InvertedIndex.from">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.</span>from
        <span class="apidocSignatureSpan">(iterable, descriptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, descriptor) {
  var index = new InvertedIndex(descriptor);

  iterateOver(iterable, function(doc) {
    index.add(doc);
  });

  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.InvertedIndex.prototype" id="apidoc.module.mnemonist.InvertedIndex.prototype">module mnemonist.InvertedIndex.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.add" id="apidoc.element.mnemonist.InvertedIndex.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>add
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (doc) {

  // Increasing size
  this.size++;

  // Storing document
  var key = this.items.length;
  this.items.push(doc);

  // Tokenizing the document
  var tokens = this.documentTokenizer(doc);

  if (!Array.isArray(tokens))
    throw new Error('mnemonist/InvertedIndex.add: tokenizer function should return an array of tokens.');

  // Indexing
  var token,
      container;

  for (var i = 0, l = tokens.length; i &lt; l; i++) {
    token = tokens[i];
    container = this.mapping.get(token);

    if (!container) {
      container = new Set();
      this.mapping.set(token, container);
    }

    container.add(key);
  }

  this.dimension = this.mapping.size;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.andQuery" id="apidoc.element.mnemonist.InvertedIndex.prototype.andQuery">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>andQuery
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">andQuery = function (query) {

  // Early termination
  if (!this.size)
    return [];

  // First we need to tokenize the query
  var tokens = this.queryTokenizer(query);

  if (!Array.isArray(tokens))
    throw new Error('mnemonist/InvertedIndex.query: tokenizer function should return an array of tokens.');

  if (!tokens.length)
    return [];

  var matchingSet = new Set(),
      token,
      set,
      i,
      l;

  for (i = 0, l = tokens.length; i &lt; l; i++) {
    token = tokens[i];
    set = this.mapping.get(token);

    // Empty intersection
    if (!set || !set.size)
      return new Set();

    if (!matchingSet.size)
      helpers.add(matchingSet, set);
    else
      helpers.intersect(matchingSet, set);
  }

  var results = new Array(matchingSet.size),
      iterator = matchingSet.values(),
      step;

  i = 0;

  while ((step = iterator.next(), !step.done))
    results[i++] = this.items[step.value];

  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.clear" id="apidoc.element.mnemonist.InvertedIndex.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.items = [];
  this.mapping = new Map();
  this.size = 0;
  this.dimension = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.documents" id="apidoc.element.mnemonist.InvertedIndex.prototype.documents">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>documents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">documents = function () {
  var documents = this.items,
      l = documents.length,
      i = 0;

  return new InvertedIndexIterator(function() {
    if (i &gt;= l)
      return {
        done: true
      };

      var value = documents[i++];

      return {
        value: value,
        done: false
      };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.forEach" id="apidoc.element.mnemonist.InvertedIndex.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  scope = arguments.length &gt; 1 ? scope : this;

  for (var i = 0, l = this.documents.length; i &lt; l; i++)
    callback.call(scope, this.documents[i], i, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.inspect" id="apidoc.element.mnemonist.InvertedIndex.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = this.documents.slice();

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: InvertedIndex,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.orQuery" id="apidoc.element.mnemonist.InvertedIndex.prototype.orQuery">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>orQuery
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">orQuery = function (query) {

  // Early termination
  if (!this.size)
    return [];

  // First we need to tokenize the query
  var tokens = this.queryTokenizer(query);

  if (!Array.isArray(tokens))
    throw new Error('mnemonist/InvertedIndex.orQuery: tokenizer function should return an array of tokens.');

  if (!tokens.length)
    return [];

  var matchingSet = new Set(),
      token,
      set,
      i,
      l;

  for (i = 0, l = tokens.length; i &lt; l; i++) {
    token = tokens[i];
    set = this.mapping.get(token);

    // Empty set
    if (!set || !set.size)
      continue;

    helpers.add(matchingSet, set);
  }

  var results = new Array(matchingSet.size),
      iterator = matchingSet.values(),
      step;

  i = 0;

  while ((step = iterator.next(), !step.done))
    results[i++] = this.items[step.value];

  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.query" id="apidoc.element.mnemonist.InvertedIndex.prototype.query">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>query
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (query) {

  // Early termination
  if (!this.size)
    return [];

  // First we need to tokenize the query
  var tokens = this.queryTokenizer(query);

  if (!Array.isArray(tokens))
    throw new Error('mnemonist/InvertedIndex.query: tokenizer function should return an array of tokens.');

  if (!tokens.length)
    return [];

  var matchingSet = new Set(),
      token,
      set,
      i,
      l;

  for (i = 0, l = tokens.length; i &lt; l; i++) {
    token = tokens[i];
    set = this.mapping.get(token);

    // Empty intersection
    if (!set || !set.size)
      return new Set();

    if (!matchingSet.size)
      helpers.add(matchingSet, set);
    else
      helpers.intersect(matchingSet, set);
  }

  var results = new Array(matchingSet.size),
      iterator = matchingSet.values(),
      step;

  i = 0;

  while ((step = iterator.next(), !step.done))
    results[i++] = this.items[step.value];

  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.InvertedIndex.prototype.tokens" id="apidoc.element.mnemonist.InvertedIndex.prototype.tokens">
        function <span class="apidocSignatureSpan">mnemonist.InvertedIndex.prototype.</span>tokens
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens = function () {
  var iterator = this.mapping.keys();

  Object.defineProperty(iterator, 'constructor', {
    value: InvertedIndexIterator,
    enumerable: false
  });

  return iterator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.LinkedList" id="apidoc.module.mnemonist.LinkedList">module mnemonist.LinkedList</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.LinkedList" id="apidoc.element.mnemonist.LinkedList.LinkedList">
        function <span class="apidocSignatureSpan">mnemonist.</span>LinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkedList() {
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.from" id="apidoc.element.mnemonist.LinkedList.from">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.</span>from
        <span class="apidocSignatureSpan">(iterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable) {
  var list = new LinkedList();

  iterateOver(iterable, function(value) {
    list.push(value);
  });

  return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.LinkedList.prototype" id="apidoc.module.mnemonist.LinkedList.prototype">module mnemonist.LinkedList.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.clear" id="apidoc.element.mnemonist.LinkedList.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.head = null;
  this.tail = null;
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.entries" id="apidoc.element.mnemonist.LinkedList.prototype.entries">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>entries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entries = function () {
  var n = this.head,
      i = 0;

  return new LinkedListIterator(function() {
    if (!n)
      return {
        done: true
      };

    var value = n.item;
    n = n.next;
    i++;

    return {
      value: [i - 1, value],
      done: false
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.first" id="apidoc.element.mnemonist.LinkedList.prototype.first">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  return this.head ? this.head.item : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.forEach" id="apidoc.element.mnemonist.LinkedList.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  if (!this.size)
    return;

  scope = arguments.length &gt; 1 ? scope : this;

  var n = this.head,
      i = 0;

  while (n) {
    callback.call(scope, n.item, i, this);
    n = n.next;
    i++;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.inspect" id="apidoc.element.mnemonist.LinkedList.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = this.toArray();

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: LinkedList,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.last" id="apidoc.element.mnemonist.LinkedList.prototype.last">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this.tail ? this.tail.item : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.peek" id="apidoc.element.mnemonist.LinkedList.prototype.peek">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.head ? this.head.item : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.push" id="apidoc.element.mnemonist.LinkedList.prototype.push">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>push
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (item) {
  var node = {item: item, next: null};

  if (!this.head) {
    this.head = node;
    this.tail = node;
  }
  else {
    this.tail.next = node;
    this.tail = node;
  }

  this.size++;

  return this.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.shift" id="apidoc.element.mnemonist.LinkedList.prototype.shift">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
  if (!this.size)
    return undefined;

  var node = this.head;

  this.head = node.next;
  this.size--;

  return node.item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.toArray" id="apidoc.element.mnemonist.LinkedList.prototype.toArray">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  if (!this.size)
    return [];

  var array = new Array(this.size);

  for (var i = 0, l = this.size, n = this.head; i &lt; l; i++) {
    array[i] = n.item;
    n = n.next;
  }

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.toJSON" id="apidoc.element.mnemonist.LinkedList.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.toString" id="apidoc.element.mnemonist.LinkedList.prototype.toString">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.toArray().join(',');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.unshift" id="apidoc.element.mnemonist.LinkedList.prototype.unshift">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>unshift
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (item) {
  var node = {item: item, next: null};

  if (!this.head) {
    this.head = node;
    this.tail = node;
  }
  else {
    if (!this.head.next)
      this.tail = this.head;
    node.next = this.head;
    this.head = node;
  }

  this.size++;

  return this.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.LinkedList.prototype.values" id="apidoc.element.mnemonist.LinkedList.prototype.values">
        function <span class="apidocSignatureSpan">mnemonist.LinkedList.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  var n = this.head;

  return new LinkedListIterator(function() {
    if (!n)
      return {
        done: true
      };

    var value = n.item;
    n = n.next;

    return {
      value: value,
      done: false
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning an iterator over the index's values.
 *
 * @return {IndexIterator}
 */
Index.prototype.values = function() {
var iterator = this.items.<span class="apidocCodeKeywordSpan">values</span>();

Object.defineProperty(iterator, 'constructor', {
  value: IndexIterator,
  enumerable: false
});

return iterator;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MaxFibonacciHeap" id="apidoc.module.mnemonist.MaxFibonacciHeap">module mnemonist.MaxFibonacciHeap</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MaxFibonacciHeap.MaxFibonacciHeap" id="apidoc.element.mnemonist.MaxFibonacciHeap.MaxFibonacciHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MaxFibonacciHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxFibonacciHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MaxFibonacciHeap.from" id="apidoc.element.mnemonist.MaxFibonacciHeap.from">
        function <span class="apidocSignatureSpan">mnemonist.MaxFibonacciHeap.</span>from
        <span class="apidocSignatureSpan">(iterable, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, comparator) {
  var heap = new MaxFibonacciHeap(comparator);

  iterateOver(iterable, function(value) {
    heap.push(value);
  });

  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MaxHeap" id="apidoc.module.mnemonist.MaxHeap">module mnemonist.MaxHeap</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MaxHeap.MaxHeap" id="apidoc.element.mnemonist.MaxHeap.MaxHeap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MaxHeap
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxHeap(comparator) {
  this.clear();
  this.comparator = comparator || DEFAULT_COMPARATOR;

  if (typeof this.comparator !== 'function')
    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');

  this.comparator = reverseComparator(this.comparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MaxHeap.from" id="apidoc.element.mnemonist.MaxHeap.from">
        function <span class="apidocSignatureSpan">mnemonist.MaxHeap.</span>from
        <span class="apidocSignatureSpan">(iterable, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, comparator) {
  var heap = new MaxHeap(comparator);

  iterateOver(iterable, function(value) {
    heap.push(value);
  });

  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MultiIndex" id="apidoc.module.mnemonist.MultiIndex">module mnemonist.MultiIndex</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.MultiIndex" id="apidoc.element.mnemonist.MultiIndex.MultiIndex">
        function <span class="apidocSignatureSpan">mnemonist.</span>MultiIndex
        <span class="apidocSignatureSpan">(descriptor, Container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiIndex(descriptor, Container) {
  this.items = new MultiMap(Container);
  this.clear();

  if (Array.isArray(descriptor)) {
    this.writeHashFunction = descriptor[0];
    this.readHashFunction = descriptor[1];
  }
  else {
    this.writeHashFunction = descriptor;
    this.readHashFunction = descriptor;
  }

  if (!this.writeHashFunction)
    this.writeHashFunction = identity;
  if (!this.readHashFunction)
    this.readHashFunction = identity;

  if (typeof this.writeHashFunction !== 'function')
    throw new Error('mnemonist/MultiIndex.constructor: invalid hash function given.');

  if (typeof this.readHashFunction !== 'function')
    throw new Error('mnemonist/MultiIndex.constructor: invalid hash function given.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.from" id="apidoc.element.mnemonist.MultiIndex.from">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.</span>from
        <span class="apidocSignatureSpan">(iterable, descriptor, Container, useSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, descriptor, Container, useSet) {
  if (arguments.length === 3) {
    if (typeof Container === 'boolean') {
      useSet = Container;
      Container = Array;
    }
  }

  var index = new MultiIndex(descriptor, Container);

  iterateOver(iterable, function(value, key) {
    if (useSet)
      index.set(key, value);
    else
      index.add(value);
  });

  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MultiIndex.prototype" id="apidoc.module.mnemonist.MultiIndex.prototype">module mnemonist.MultiIndex.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.prototype.add" id="apidoc.element.mnemonist.MultiIndex.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>add
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (item) {
  var key = this.writeHashFunction(item);

  this.items.set(key, item);
  this.size = this.items.size;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.prototype.clear" id="apidoc.element.mnemonist.MultiIndex.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  this.items.clear();

  // Properties
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.prototype.forEach" id="apidoc.element.mnemonist.MultiIndex.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  scope = arguments.length &gt; 1 ? scope : this;

  this.items.forEach(function(value) {
    callback.call(scope, value, value);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.prototype.get" id="apidoc.element.mnemonist.MultiIndex.prototype.get">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  key = this.readHashFunction(key);

  return this.items.get(key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param  {any} key - Key to use.
* @return {Index}
*/
Index.prototype.get = function(key) {
 key = this.readHashFunction(key);

 return this.items.<span class="apidocCodeKeywordSpan">get</span>(key);
};

/**
* Method used to iterate over each of the index's values.
*
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.prototype.inspect" id="apidoc.element.mnemonist.MultiIndex.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = Array.from(this);

  Object.defineProperty(array, 'constructor', {
    value: MultiIndex,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.prototype.set" id="apidoc.element.mnemonist.MultiIndex.prototype.set">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>set
        <span class="apidocSignatureSpan">(key, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, item) {
  key = this.writeHashFunction(key);

  this.items.set(key, item);
  this.size = this.items.size;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param  {any} item - Item to add.
* @return {Index}
*/
Index.prototype.add = function(item) {
 var key = this.writeHashFunction(item);

 this.items.<span class="apidocCodeKeywordSpan">set</span>(key, item);
 this.size = this.items.size;

 return this;
};

/**
* Method used to set an item in the index using the given key.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiIndex.prototype.values" id="apidoc.element.mnemonist.MultiIndex.prototype.values">
        function <span class="apidocSignatureSpan">mnemonist.MultiIndex.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  var iterator = this.items.values();

  Object.defineProperty(iterator, 'constructor', {
    value: MultiIndexIterator,
    enumerable: false
  });

  return iterator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning an iterator over the index's values.
 *
 * @return {IndexIterator}
 */
Index.prototype.values = function() {
var iterator = this.items.<span class="apidocCodeKeywordSpan">values</span>();

Object.defineProperty(iterator, 'constructor', {
  value: IndexIterator,
  enumerable: false
});

return iterator;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MultiMap" id="apidoc.module.mnemonist.MultiMap">module mnemonist.MultiMap</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.MultiMap" id="apidoc.element.mnemonist.MultiMap.MultiMap">
        function <span class="apidocSignatureSpan">mnemonist.</span>MultiMap
        <span class="apidocSignatureSpan">(Container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiMap(Container) {

  this.Container = Container || Array;
  this.items = new Map();
  this.clear();

  Object.defineProperty(this.items, 'constructor', {
    value: MultiMap,
    enumerable: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.from" id="apidoc.element.mnemonist.MultiMap.from">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.</span>from
        <span class="apidocSignatureSpan">(iterable, Container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, Container) {
  var map = new MultiMap(Container);

  iterateOver(iterable, function(value, key) {
    map.set(key, value);
  });

  return map;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MultiMap.prototype" id="apidoc.module.mnemonist.MultiMap.prototype">module mnemonist.MultiMap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.associations" id="apidoc.element.mnemonist.MultiMap.prototype.associations">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>associations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">associations = function () {
  var iterator = this.items.entries();

  Object.defineProperty(iterator, 'constructor', {
    value: MultiMapIterator,
    enumerable: false
  });

  return iterator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.clear" id="apidoc.element.mnemonist.MultiMap.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.size = 0;
  this.dimension = 0;
  this.items.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.containers" id="apidoc.element.mnemonist.MultiMap.prototype.containers">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>containers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">containers = function () {
  var iterator = this.items.values();

  Object.defineProperty(iterator, 'constructor', {
    value: MultiMapIterator,
    enumerable: false
  });

  return iterator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.delete" id="apidoc.element.mnemonist.MultiMap.prototype.delete">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>delete
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (key) {
  var container = this.items.get(key);

  if (container) {
    this.size -= (this.Container === Set ? container.size : container.length);
    this.dimension--;
  }

  this.items.delete(key);

  return !!container;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.entries" id="apidoc.element.mnemonist.MultiMap.prototype.entries">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>entries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entries = function () {
  var iterator = this.items.entries(),
      inContainer = false,
      countainer,
      step,
      key,
      i,
      l;

  if (this.Container === Set)
    return new MultiMapIterator(function next() {
      if (!inContainer) {
        step = iterator.next();

        if (step.done)
          return {done: true};

        inContainer = true;
        key = step.value[0];
        countainer = step.value[1].values();
      }

      step = countainer.next();

      if (step.done) {
        inContainer = false;
        return next();
      }

      return {
        done: false,
        value: [key, step.value]
      };
    });

  return new MultiMapIterator(function next() {
    if (!inContainer) {
      step = iterator.next();

      if (step.done)
        return {done: true};

      inContainer = true;
      key = step.value[0];
      countainer = step.value[1];
      i = 0;
      l = countainer.length;
    }

    if (i &gt;= l) {
      inContainer = false;
      return next();
    }

    return {
      done: false,
      value: [key, countainer[i++]]
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.forEach" id="apidoc.element.mnemonist.MultiMap.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  scope = arguments.length &gt; 1 ? scope : this;

  this.items.forEach(function(container, key) {
    container.forEach(function(value) {
      callback.call(scope, value, key);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.get" id="apidoc.element.mnemonist.MultiMap.prototype.get">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  return this.items.get(key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param  {any} key - Key to use.
* @return {Index}
*/
Index.prototype.get = function(key) {
 key = this.readHashFunction(key);

 return this.items.<span class="apidocCodeKeywordSpan">get</span>(key);
};

/**
* Method used to iterate over each of the index's values.
*
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.has" id="apidoc.element.mnemonist.MultiMap.prototype.has">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>has
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (key) {
  return this.items.has(key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.inspect" id="apidoc.element.mnemonist.MultiMap.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  return this.items;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.keys" id="apidoc.element.mnemonist.MultiMap.prototype.keys">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function () {
  var iterator = this.items.keys();

  Object.defineProperty(iterator, 'constructor', {
    value: MultiMapIterator,
    enumerable: false
  });

  return iterator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.set" id="apidoc.element.mnemonist.MultiMap.prototype.set">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>set
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value) {
  var container = this.items.get(key),
      sizeIncrease = 0;

  if (!container) {
    this.dimension++;
    container = new this.Container();
    this.items.set(key, container);
  }

  if (this.Container === Set) {
    sizeIncrease = +!container.has(value);
    container.add(value);
  }
  else {
    sizeIncrease = 1;
    container.push(value);
  }

  this.size += sizeIncrease;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param  {any} item - Item to add.
* @return {Index}
*/
Index.prototype.add = function(item) {
 var key = this.writeHashFunction(item);

 this.items.<span class="apidocCodeKeywordSpan">set</span>(key, item);
 this.size = this.items.size;

 return this;
};

/**
* Method used to set an item in the index using the given key.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.toJSON" id="apidoc.element.mnemonist.MultiMap.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.items;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiMap.prototype.values" id="apidoc.element.mnemonist.MultiMap.prototype.values">
        function <span class="apidocSignatureSpan">mnemonist.MultiMap.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  var iterator = this.items.values(),
      inContainer = false,
      countainer,
      step,
      i,
      l;

  if (this.Container === Set)
    return new MultiMapIterator(function next() {
      if (!inContainer) {
        step = iterator.next();

        if (step.done)
          return {done: true};

        inContainer = true;
        countainer = step.value.values();
      }

      step = countainer.next();

      if (step.done) {
        inContainer = false;
        return next();
      }

      return {
        done: false,
        value: step.value
      };
    });

  return new MultiMapIterator(function next() {
    if (!inContainer) {
      step = iterator.next();

      if (step.done)
        return {done: true};

      inContainer = true;
      countainer = step.value;
      i = 0;
      l = countainer.length;
    }

    if (i &gt;= l) {
      inContainer = false;
      return next();
    }

    return {
      done: false,
      value: countainer[i++]
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning an iterator over the index's values.
 *
 * @return {IndexIterator}
 */
Index.prototype.values = function() {
var iterator = this.items.<span class="apidocCodeKeywordSpan">values</span>();

Object.defineProperty(iterator, 'constructor', {
  value: IndexIterator,
  enumerable: false
});

return iterator;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MultiSet" id="apidoc.module.mnemonist.MultiSet">module mnemonist.MultiSet</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.MultiSet" id="apidoc.element.mnemonist.MultiSet.MultiSet">
        function <span class="apidocSignatureSpan">mnemonist.</span>MultiSet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiSet() {
  this.items = new Map();

  Object.defineProperty(this.items, 'constructor', {
    value: MultiSet,
    enumerable: false
  });

  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.from" id="apidoc.element.mnemonist.MultiSet.from">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.</span>from
        <span class="apidocSignatureSpan">(iterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable) {
  var set = new MultiSet();

  iterateOver(iterable, function(value) {
    set.add(value);
  });

  return set;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.MultiSet.prototype" id="apidoc.module.mnemonist.MultiSet.prototype">module mnemonist.MultiSet.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.add" id="apidoc.element.mnemonist.MultiSet.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>add
        <span class="apidocSignatureSpan">(item, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (item, count) {
  count = count || 1;

  this.size += count;

  if (!this.items.has(item)) {
    this.dimension++;
  }
  else {
    count += this.items.get(item);
  }

  this.items.set(item, count);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.clear" id="apidoc.element.mnemonist.MultiSet.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.size = 0;
  this.dimension = 0;
  this.items.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.delete" id="apidoc.element.mnemonist.MultiSet.prototype.delete">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>delete
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (item) {
  var count = this.multiplicity(item);

  this.size -= count;
  this.dimension--;
  this.items.delete(item);

  return !!count;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.forEach" id="apidoc.element.mnemonist.MultiSet.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  scope = arguments.length &gt; 1 ? scope : this;

  var i;

  this.items.forEach(function(multiplicty, value) {

    for (i = 0; i &lt; multiplicty; i++)
      callback.call(scope, value, value);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.has" id="apidoc.element.mnemonist.MultiSet.prototype.has">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>has
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (item) {
  return this.items.has(item);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.inspect" id="apidoc.element.mnemonist.MultiSet.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  return this.items;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.multiplicities" id="apidoc.element.mnemonist.MultiSet.prototype.multiplicities">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>multiplicities
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiplicities = function () {
  var iterator = this.items.entries();

  Object.defineProperty(iterator, 'constructor', {
    value: MultiSet,
    enumerable: false
  });

  return iterator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.multiplicity" id="apidoc.element.mnemonist.MultiSet.prototype.multiplicity">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>multiplicity
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiplicity = function (item) {
  return this.items.get(item) || 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.remove" id="apidoc.element.mnemonist.MultiSet.prototype.remove">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>remove
        <span class="apidocSignatureSpan">(item, count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (item, count) {
  count = count || 1;

  var currentCount = this.multiplicity(item),
      newCount = Math.max(0, currentCount - count);

  if (!newCount) {
    this.delete(item);
  }
  else {
    this.items.set(item, newCount);
    this.size -= (currentCount - newCount);
  }

  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.toJSON" id="apidoc.element.mnemonist.MultiSet.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.items;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.MultiSet.prototype.values" id="apidoc.element.mnemonist.MultiSet.prototype.values">
        function <span class="apidocSignatureSpan">mnemonist.MultiSet.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  var iterator = this.items.entries(),
      inContainer = false,
      step,
      value,
      multiplicty,
      i;

  return new MultiSetIterator(function next() {
    if (!inContainer) {
      step = iterator.next();

      if (step.done)
        return {done: true};

      inContainer = true;
      value = step.value[0];
      multiplicty = step.value[1];
      i = 0;
    }

    if (i &gt;= multiplicty) {
      inContainer = false;
      return next();
    }

    i++;

    return {
      done: false,
      value: value
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning an iterator over the index's values.
 *
 * @return {IndexIterator}
 */
Index.prototype.values = function() {
var iterator = this.items.<span class="apidocCodeKeywordSpan">values</span>();

Object.defineProperty(iterator, 'constructor', {
  value: IndexIterator,
  enumerable: false
});

return iterator;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Queue" id="apidoc.module.mnemonist.Queue">module mnemonist.Queue</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Queue.Queue" id="apidoc.element.mnemonist.Queue.Queue">
        function <span class="apidocSignatureSpan">mnemonist.</span>Queue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue() {
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.from" id="apidoc.element.mnemonist.Queue.from">
        function <span class="apidocSignatureSpan">mnemonist.Queue.</span>from
        <span class="apidocSignatureSpan">(iterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable) {
  var queue = new Queue();

  iterateOver(iterable, function(value) {
    queue.enqueue(value);
  });

  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Queue.prototype" id="apidoc.module.mnemonist.Queue.prototype">module mnemonist.Queue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.clear" id="apidoc.element.mnemonist.Queue.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.items = [];
  this.offset = 0;
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.dequeue" id="apidoc.element.mnemonist.Queue.prototype.dequeue">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>dequeue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dequeue = function () {
  if (!this.size)
    return;

  var item = this.items[this.offset];

  if (++this.offset * 2 &gt;= this.items.length) {
    this.items = this.items.slice(this.offset);
    this.offset = 0;
  }

  this.size--;

  return item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.enqueue" id="apidoc.element.mnemonist.Queue.prototype.enqueue">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueue = function (item) {

  this.items.push(item);
  return ++this.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.entries" id="apidoc.element.mnemonist.Queue.prototype.entries">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>entries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entries = function () {
  var items = this.items,
      i = this.offset,
      j = 0;

  return new QueueIterator(function() {
    if (i &gt;= items.length)
      return {
        done: true
      };

    var value = items[i];
    i++;

    return {
      value: [j++, value],
      done: false
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.forEach" id="apidoc.element.mnemonist.Queue.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  scope = arguments.length &gt; 1 ? scope : this;

  for (var i = this.offset, j = 0, l = this.items.length; i &lt; l; i++, j++)
    callback.call(scope, this.items[i], j, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.inspect" id="apidoc.element.mnemonist.Queue.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = this.toArray();

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: Queue,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.peek" id="apidoc.element.mnemonist.Queue.prototype.peek">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  if (!this.size)
    return;

  return this.items[this.offset];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.toArray" id="apidoc.element.mnemonist.Queue.prototype.toArray">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  return this.items.slice(this.offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.toJSON" id="apidoc.element.mnemonist.Queue.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.toString" id="apidoc.element.mnemonist.Queue.prototype.toString">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.toArray().join(',');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Queue.prototype.values" id="apidoc.element.mnemonist.Queue.prototype.values">
        function <span class="apidocSignatureSpan">mnemonist.Queue.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  var items = this.items,
      i = this.offset;

  return new QueueIterator(function() {
    if (i &gt;= items.length)
      return {
        done: true
      };

    var value = items[i];
    i++;

    return {
      value: value,
      done: false
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning an iterator over the index's values.
 *
 * @return {IndexIterator}
 */
Index.prototype.values = function() {
var iterator = this.items.<span class="apidocCodeKeywordSpan">values</span>();

Object.defineProperty(iterator, 'constructor', {
  value: IndexIterator,
  enumerable: false
});

return iterator;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Set" id="apidoc.module.mnemonist.Set">module mnemonist.Set</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Set.add" id="apidoc.element.mnemonist.Set.add">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>add
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (A, B) {
  var iterator = B.values(),
      step;

  while ((step = iterator.next(), !step.done))
    A.add(step.value);

  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.difference" id="apidoc.element.mnemonist.Set.difference">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>difference
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">difference = function (A, B) {

  // If first set is empty
  if (!A.size)
    return new Set();

  if (!B.size)
    return new Set(A);

  var D = new Set();

  var iterator = A.values(),
      step;

  while ((step = iterator.next(), !step.done)) {
    if (!B.has(step.value))
      D.add(step.value);
  }

  return D;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.disjunct" id="apidoc.element.mnemonist.Set.disjunct">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>disjunct
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disjunct = function (A, B) {
  var iterator = A.values(),
      step;

  var toRemove = [];

  while ((step = iterator.next(), !step.done)) {
    if (B.has(step.value))
      toRemove.push(step.value);
  }

  iterator = B.values();

  while ((step = iterator.next(), !step.done)) {
    if (!A.has(step.value))
      A.add(step.value);
  }

  for (var i = 0, l = toRemove.length; i &lt; l; i++)
    A.delete(toRemove[i]);

  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.intersect" id="apidoc.element.mnemonist.Set.intersect">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>intersect
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersect = function (A, B) {
  var iterator = A.values(),
      step;

  while ((step = iterator.next(), !step.done)) {
    if (!B.has(step.value))
      A.delete(step.value);
  }

  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.intersection" id="apidoc.element.mnemonist.Set.intersection">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>intersection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersection = function () {
  if (arguments.length &lt; 2)
    throw new Error('mnemonist/Set.intersection: needs at least two arguments.');

  var I = new Set();

  // First we need to find the smallest set
  var smallestSize = Infinity,
      smallestSet = null;

  var s, i, l = arguments.length;

  for (i = 0; i &lt; l; i++) {
    s = arguments[i];

    // If one of the set has no items, we can stop right there
    if (s.size === 0)
      return I;

    if (s.size &lt; smallestSize) {
      smallestSize = s.size;
      smallestSet = s;
    }
  }

  // Now we need to intersect this set with the others
  var iterator = smallestSet.values(),
      step,
      item,
      add,
      set;

  while ((step = iterator.next(), !step.done)) {
    item = step.value;
    add = true;

    for (i = 0; i &lt; l; i++) {
      set = arguments[i];

      if (set === smallestSet)
        continue;

      if (!set.has(item)) {
        add = false;
        break;
      }
    }

    if (add)
      I.add(item);
  }

  return I;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.isSubset" id="apidoc.element.mnemonist.Set.isSubset">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>isSubset
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSubset = function (A, B) {
  var iterator = A.values(),
      step;

  while ((step = iterator.next(), !step.done)) {
    if (!B.has(step.value))
      return false;
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.isSuperset" id="apidoc.element.mnemonist.Set.isSuperset">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>isSuperset
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSuperset = function (A, B) {
  return exports.isSubset(B, A);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.subtract" id="apidoc.element.mnemonist.Set.subtract">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>subtract
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function (A, B) {
  var iterator = B.values(),
      step;

  while ((step = iterator.next(), !step.done))
    A.delete(step.value);

  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.symmetricDifference" id="apidoc.element.mnemonist.Set.symmetricDifference">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>symmetricDifference
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symmetricDifference = function (A, B) {
  var S = new Set();

  var iterator = A.values(),
      step;

  while ((step = iterator.next(), !step.done)) {
    if (!B.has(step.value))
      S.add(step.value);
  }

  iterator = B.values();

  while ((step = iterator.next(), !step.done)) {
    if (!A.has(step.value))
      S.add(step.value);
  }

  return S;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Set.union" id="apidoc.element.mnemonist.Set.union">
        function <span class="apidocSignatureSpan">mnemonist.Set.</span>union
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function () {
  if (arguments.length &lt; 2)
    throw new Error('mnemonist/Set.union: needs at least two arguments.');

  var U = new Set();

  var i, l = arguments.length;

  var iterator,
      step;

  for (i = 0; i &lt; l; i++) {
    iterator = arguments[i].values();

    while ((step = iterator.next(), !step.done))
      U.add(step.value);
  }

  return U;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Stack" id="apidoc.module.mnemonist.Stack">module mnemonist.Stack</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Stack.Stack" id="apidoc.element.mnemonist.Stack.Stack">
        function <span class="apidocSignatureSpan">mnemonist.</span>Stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack() {
  this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.from" id="apidoc.element.mnemonist.Stack.from">
        function <span class="apidocSignatureSpan">mnemonist.Stack.</span>from
        <span class="apidocSignatureSpan">(iterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable) {
  var stack = new Stack();

  iterateOver(iterable, function(value) {
    stack.push(value);
  });

  return stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Stack.prototype" id="apidoc.module.mnemonist.Stack.prototype">module mnemonist.Stack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.clear" id="apidoc.element.mnemonist.Stack.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.items = [];
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.entries" id="apidoc.element.mnemonist.Stack.prototype.entries">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>entries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entries = function () {
  var items = this.items,
      l = items.length,
      i = 0;

  return new StackIterator(function() {
    if (i &gt;= l)
      return {
        done: true
      };

    var value = items[l - i - 1];

    return {
      value: [i++, value],
      done: false
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.forEach" id="apidoc.element.mnemonist.Stack.prototype.forEach">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, scope) {
  scope = arguments.length &gt; 1 ? scope : this;

  for (var i = 0, l = this.items.length; i &lt; l; i++)
    callback.call(scope, this.items[l - i - 1], i, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
* @return {undefined}
*/
Index.prototype.forEach = function(callback, scope) {
 scope = arguments.length &gt; 1 ? scope : this;

 this.items.<span class="apidocCodeKeywordSpan">forEach</span>(function(value) {
   callback.call(scope, value, value);
 });
};


/**
* Index Iterator class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.inspect" id="apidoc.element.mnemonist.Stack.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = this.toArray();

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: Stack,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.peek" id="apidoc.element.mnemonist.Stack.prototype.peek">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.items[this.items.length - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.pop" id="apidoc.element.mnemonist.Stack.prototype.pop">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  this.size--;
  return this.items.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.push" id="apidoc.element.mnemonist.Stack.prototype.push">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>push
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (item) {
  this.items.push(item);
  return ++this.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.toArray" id="apidoc.element.mnemonist.Stack.prototype.toArray">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  return this.items.slice(0).reverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.toJSON" id="apidoc.element.mnemonist.Stack.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.toString" id="apidoc.element.mnemonist.Stack.prototype.toString">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.toArray().join(',');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Stack.prototype.values" id="apidoc.element.mnemonist.Stack.prototype.values">
        function <span class="apidocSignatureSpan">mnemonist.Stack.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  var items = this.items,
      l = items.length,
      i = 0;

  return new StackIterator(function() {
    if (i &gt;= l)
      return {
        done: true
      };

    var value = items[l - i - 1];
    i++;

    return {
      value: value,
      done: false
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Method returning an iterator over the index's values.
 *
 * @return {IndexIterator}
 */
Index.prototype.values = function() {
var iterator = this.items.<span class="apidocCodeKeywordSpan">values</span>();

Object.defineProperty(iterator, 'constructor', {
  value: IndexIterator,
  enumerable: false
});

return iterator;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.SuffixArray" id="apidoc.module.mnemonist.SuffixArray">module mnemonist.SuffixArray</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.SuffixArray.SuffixArray" id="apidoc.element.mnemonist.SuffixArray.SuffixArray">
        function <span class="apidocSignatureSpan">mnemonist.</span>SuffixArray
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SuffixArray(string) {

  // Properties
  this.hasArbitrarySequence = typeof string !== 'string';
  this.string = string;
  this.length = string.length;

  // Building the array
  this.array = build(convert(string), this.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SuffixArray.GeneralizedSuffixArray" id="apidoc.element.mnemonist.SuffixArray.GeneralizedSuffixArray">
        function <span class="apidocSignatureSpan">mnemonist.SuffixArray.</span>GeneralizedSuffixArray
        <span class="apidocSignatureSpan">(strings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GeneralizedSuffixArray(strings) {

  // Properties
  this.hasArbitrarySequence = typeof strings[0] !== 'string';
  this.size = strings.length;

  if (this.hasArbitrarySequence) {
    this.text = [];

    for (var i = 0, l = this.size; i &lt; l; i++) {
      this.text.push.apply(this.text, strings[i]);

      if (i &lt; l - 1)
        this.text.push(SEPARATOR);
    }
  }
  else {
    this.text = strings.join(SEPARATOR);
  }

  this.firstLength = strings[0].length;
  this.length = this.text.length;

  // Building the array
  this.array = build(convert(this.text), this.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.SuffixArray.prototype" id="apidoc.module.mnemonist.SuffixArray.prototype">module mnemonist.SuffixArray.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.SuffixArray.prototype.inspect" id="apidoc.element.mnemonist.SuffixArray.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.SuffixArray.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = new Array(this.length);

  for (var i = 0; i &lt; this.length; i++)
    array[i] = this.string.slice(this.array[i]);

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: SuffixArray,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SuffixArray.prototype.toJSON" id="apidoc.element.mnemonist.SuffixArray.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.SuffixArray.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SuffixArray.prototype.toString" id="apidoc.element.mnemonist.SuffixArray.prototype.toString">
        function <span class="apidocSignatureSpan">mnemonist.SuffixArray.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.array.join(',');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.SymSpell" id="apidoc.module.mnemonist.SymSpell">module mnemonist.SymSpell</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.SymSpell.SymSpell" id="apidoc.element.mnemonist.SymSpell.SymSpell">
        function <span class="apidocSignatureSpan">mnemonist.</span>SymSpell
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymSpell(options) {
  options = options || {};

  this.clear();

  // Properties
  this.maxDistance = typeof options.maxDistance === 'number' ?
    options.maxDistance :
    DEFAULT_MAX_DISTANCE;
  this.verbosity = typeof options.verbosity === 'number' ?
    options.verbosity :
    DEFAULT_VERBOSITY;

  // Sanity checks
  if (typeof this.maxDistance !== 'number' || this.maxDistance &lt;= 0)
    throw Error('mnemonist/SymSpell.constructor: invalid `maxDistance` option. Should be a integer greater than 0.');

  if (!VERBOSITY.has(this.verbosity))
    throw Error('mnemonist/SymSpell.constructor: invalid `verbosity` option. Should be either 0, 1 or 2.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SymSpell.from" id="apidoc.element.mnemonist.SymSpell.from">
        function <span class="apidocSignatureSpan">mnemonist.SymSpell.</span>from
        <span class="apidocSignatureSpan">(iterable, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, options) {
  var index = new SymSpell(options);

  iterateOver(iterable, function(value) {
    index.add(value);
  });

  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.SymSpell.prototype" id="apidoc.module.mnemonist.SymSpell.prototype">module mnemonist.SymSpell.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.SymSpell.prototype.add" id="apidoc.element.mnemonist.SymSpell.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>add
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (word) {
  var item = this.dictionary[word];

  if (item !== undefined) {
    if (typeof item === 'number') {
      item = createDictionaryItem(item);
      this.dictionary[word] = item;
    }

    item.count++;
  }

  else {
    item = createDictionaryItem();
    item.count++;

    this.dictionary[word] = item;

    if (word.length &gt; this.maxLength)
      this.maxLength = word.length;
  }

  if (item.count === 1) {
    var number = this.words.length;
    this.words.push(word);

    var deletes = edits(word, 0, this.maxDistance);

    deletes.forEach(deletedItem =&gt; {
      var target = this.dictionary[deletedItem];

      if (target !== undefined) {
        if (typeof target === 'number') {
          target = createDictionaryItem(target);

          this.dictionary[deletedItem] = target;
        }

        if (!target.suggestions.has(number)) {
          addLowestDistance(
            this.words,
            this.verbosity,
            target,
            word,
            number,
            deletedItem
          );
        }
      }
      else {
        this.dictionary[deletedItem] = number;
      }
    });
  }

  this.size++;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SymSpell.prototype.clear" id="apidoc.element.mnemonist.SymSpell.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.size = 0;
  this.dictionary = Object.create(null);
  this.maxLength = 0;
  this.words = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SymSpell.prototype.inspect" id="apidoc.element.mnemonist.SymSpell.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = [];

  array.size = this.size;
  array.maxDistance = this.maxDistance;
  array.verbosity = this.verbosity;
  array.behavior = VERBOSITY_EXPLANATIONS[this.verbosity];

  for (var k in this.dictionary) {
    if (typeof this.dictionary[k] === 'object' &amp;&amp; this.dictionary[k].count)
      array.push([k, this.dictionary[k].count]);
  }

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: SymSpell,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.SymSpell.prototype.search" id="apidoc.element.mnemonist.SymSpell.prototype.search">
        function <span class="apidocSignatureSpan">mnemonist.SymSpell.prototype.</span>search
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (input) {
  return lookup(
    this.dictionary,
    this.words,
    this.verbosity,
    this.maxDistance,
    this.maxLength,
    input
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Trie" id="apidoc.module.mnemonist.Trie">module mnemonist.Trie</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Trie.Trie" id="apidoc.element.mnemonist.Trie.Trie">
        function <span class="apidocSignatureSpan">mnemonist.</span>Trie
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trie() {
  this.clear();
  this.end = SENTINEL;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.from" id="apidoc.element.mnemonist.Trie.from">
        function <span class="apidocSignatureSpan">mnemonist.Trie.</span>from
        <span class="apidocSignatureSpan">(iterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable) {
  var trie = new Trie();

  iterateOver(iterable, function(value) {
    trie.add(value);
  });

  return trie;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.Trie.prototype" id="apidoc.module.mnemonist.Trie.prototype">module mnemonist.Trie.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.add" id="apidoc.element.mnemonist.Trie.prototype.add">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>add
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (item) {
  if (typeof item === 'string')
    item = item.split('');

  if (!item || !item.length)
    return this;

  var node = this.root,
      token;

  for (var i = 0, l = item.length; i &lt; l; i++) {
    token = item[i];

    if (!node.hasOwnProperty(token))
      node[token] = {};

    node = node[token];
  }

  // The item already exists in the trie, we don't need to increase size
  if (node[this.end])
    return this;

  node[this.end] = true;

  this.size++;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Index.from = function(iterable, descriptor, useSet) {
 var index = new Index(descriptor);

 iterateOver(iterable, function(value, key) {
   if (useSet)
     index.set(key, value);
   else
     index.<span class="apidocCodeKeywordSpan">add</span>(value);
 });

 return index;
};

/**
* Exporting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.clear" id="apidoc.element.mnemonist.Trie.prototype.clear">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {

  // Properties
  this.root = {};
  this.size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Index.
 *
 * @constructor
 * @param {array|function} descriptor - Hash functions descriptor.
 */
function Index(descriptor) {
this.items = new Map();
this.<span class="apidocCodeKeywordSpan">clear</span>();

if (Array.isArray(descriptor)) {
  this.writeHashFunction = descriptor[0];
  this.readHashFunction = descriptor[1];
}
else {
  this.writeHashFunction = descriptor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.delete" id="apidoc.element.mnemonist.Trie.prototype.delete">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>delete
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (item) {
  if (typeof item === 'string')
    item = item.split('');

  if (!item || !item.length)
    return false;

  var node = this.root,
      prefix = [],
      token,
      i,
      l;

  for (i = 0, l = item.length; i &lt; l; i++) {
    token = item[i];

    if (!node.hasOwnProperty(token))
      return false;

    node = node[token];
    prefix.push([token, node]);
  }

  if (!node[this.end])
    return false;

  this.size--;

  delete node[this.end];

  if (Object.keys(node).length &gt;= 1)
    return true;

  for (i = prefix.length - 1; i &gt;= 1; i--) {
    if (Object.keys(prefix[i][1]).length &lt; 2)
      delete prefix[i - 1][1][prefix[i][0]];
    else
      break;
  }

  if (Object.keys(this.root[prefix[0][0]]).length &lt; 2)
    delete this.root[prefix[0][0]];

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.get" id="apidoc.element.mnemonist.Trie.prototype.get">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>get
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (prefix) {
  var string = typeof prefix === 'string',
      item = prefix,
      matches = [];

  if (!item || !item.length)
    return matches;

  var node = this.root,
      token;

  for (var i = 0, l = item.length; i &lt; l; i++) {
    token = item[i];
    node = node[token];

    if (!node)
      return matches;
  }

  var stack = [node, string ? '' : []],
      tokens,
      k;

  while (stack.length) {
    tokens = stack.pop();
    node = stack.pop();

    if (node[this.end])
      matches.push(string ? prefix + tokens : prefix.concat(tokens));

    for (k in node) {
      if (k === this.end)
        continue;

      stack.push(node[k]);
      stack.push(string ? tokens + k : tokens.concat(k));
    }
  }

  return matches;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param  {any} key - Key to use.
* @return {Index}
*/
Index.prototype.get = function(key) {
 key = this.readHashFunction(key);

 return this.items.<span class="apidocCodeKeywordSpan">get</span>(key);
};

/**
* Method used to iterate over each of the index's values.
*
* @param  {function}  callback - Function to call for each item.
* @param  {object}    scope    - Optional scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.has" id="apidoc.element.mnemonist.Trie.prototype.has">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>has
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (item) {
  if (typeof item === 'string')
    item = item.split('');

  if (!item || !item.length)
    return false;

  var node = this.root,
      token;

  for (var i = 0, l = item.length; i &lt; l; i++) {
    token = item[i];

    if (!node.hasOwnProperty(token))
      return false;

    node = node[token];
  }

  return this.end in node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.inspect" id="apidoc.element.mnemonist.Trie.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var proxy = {
    size: this.size
  };

  // Trick so that node displays the name of the constructor
  Object.defineProperty(proxy, 'constructor', {
    value: Trie,
    enumerable: false
  });

  return proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.longestPrefix" id="apidoc.element.mnemonist.Trie.prototype.longestPrefix">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>longestPrefix
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">longestPrefix = function (item) {
  var string = typeof item === 'string';

  if (string)
    item = item.split('');

  if (!item || !item.length)
    return string ? '' : [];

  var prefix = [],
      node = this.root,
      token;

  for (var i = 0, l = item.length; i &lt; l; i++) {
    token = item[i];

    if (!node.hasOwnProperty(token))
      break;

    prefix.push(token);
    node = node[token];
  }

  return string ? prefix.join('') : prefix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.Trie.prototype.toJSON" id="apidoc.element.mnemonist.Trie.prototype.toJSON">
        function <span class="apidocSignatureSpan">mnemonist.Trie.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.VPTree" id="apidoc.module.mnemonist.VPTree">module mnemonist.VPTree</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.VPTree.VPTree" id="apidoc.element.mnemonist.VPTree.VPTree">
        function <span class="apidocSignatureSpan">mnemonist.</span>VPTree
        <span class="apidocSignatureSpan">(distance, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VPTree(distance, items) {
  if (typeof distance !== 'function')
    throw new Error('mnemonist/VPTree.constructor: given `distance` must be a function.');

  if (!items)
    throw new Error('mnemonist/VPTree.constructor: you must provide items to the tree. A VPTree cannot be updated after its creation
.');

  // Properties
  this.distance = distance;
  this.items = [];

  var indexes = [],
      self = this,
      i = 0;

  iterateOver(items, function(value) {
    self.items.push(value);
    indexes.push(i++);
  });

  // Creating the binary tree
  this.size = indexes.length;
  this.data = createBinaryTree(distance, this.items, indexes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.VPTree.from" id="apidoc.element.mnemonist.VPTree.from">
        function <span class="apidocSignatureSpan">mnemonist.VPTree.</span>from
        <span class="apidocSignatureSpan">(iterable, distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (iterable, distance) {
  return new VPTree(distance, iterable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof Symbol !== 'undefined')
Index.prototype[Symbol.iterator] = Index.prototype.values;

/**
 * Convenience known method.
 */
Index.prototype.inspect = function() {
var array = Array.<span class="apidocCodeKeywordSpan">from</span>(this.items.values());

Object.defineProperty(array, 'constructor', {
  value: Index,
  enumerable: false
});

return array;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.VPTree.prototype" id="apidoc.module.mnemonist.VPTree.prototype">module mnemonist.VPTree.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.VPTree.prototype.inspect" id="apidoc.element.mnemonist.VPTree.prototype.inspect">
        function <span class="apidocSignatureSpan">mnemonist.VPTree.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var array = this.items.slice();

  // Trick so that node displays the name of the constructor
  Object.defineProperty(array, 'constructor', {
    value: VPTree,
    enumerable: false
  });

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.VPTree.prototype.nearestNeighbors" id="apidoc.element.mnemonist.VPTree.prototype.nearestNeighbors">
        function <span class="apidocSignatureSpan">mnemonist.VPTree.prototype.</span>nearestNeighbors
        <span class="apidocSignatureSpan">(k, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nearestNeighbors = function (k, query) {
  var neighbors = new Heap(comparator),
      stack = [0],
      tau = Infinity,
      nodeIndex,
      itemIndex,
      vantagePoint,
      leftIndex,
      rightIndex,
      mu,
      d;

  while (stack.length) {
    nodeIndex = stack.pop();
    itemIndex = this.data[nodeIndex];
    vantagePoint = this.items[itemIndex];

    // Distance between query &amp; the current vantage point
    d = this.distance(vantagePoint, query);

    if (d &lt; tau) {
      neighbors.push({distance: d, item: vantagePoint});

      // Trimming
      if (neighbors.size &gt; k)
        neighbors.pop();

      // Adjusting tau
      tau = neighbors.peek().distance;
    }

    leftIndex = this.data[nodeIndex + 2];
    rightIndex = this.data[nodeIndex + 3];

    // We are a leaf
    if (!leftIndex &amp;&amp; !rightIndex)
      continue;

    mu = this.data[nodeIndex + 1];

    if (d &lt; mu) {
      if (leftIndex &amp;&amp; d &lt; mu + tau)
        stack.push(leftIndex);
      if (rightIndex &amp;&amp; d &gt;= mu - tau) // ALT
        stack.push(rightIndex);
    }
    else {
      if (rightIndex &amp;&amp; d &gt;= mu - tau)
        stack.push(rightIndex);
      if (leftIndex &amp;&amp; d &lt; mu + tau) // ALT
        stack.push(leftIndex);
    }
  }

  var array = new Array(neighbors.size);

  for (var i = neighbors.size - 1; i &gt;= 0; i--)
    array[i] = neighbors.pop();

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.VPTree.prototype.neighbors" id="apidoc.element.mnemonist.VPTree.prototype.neighbors">
        function <span class="apidocSignatureSpan">mnemonist.VPTree.prototype.</span>neighbors
        <span class="apidocSignatureSpan">(radius, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neighbors = function (radius, query) {
  var neighbors = [],
      stack = [0],
      nodeIndex,
      itemIndex,
      vantagePoint,
      leftIndex,
      rightIndex,
      mu,
      d;

  while (stack.length) {
    nodeIndex = stack.pop();
    itemIndex = this.data[nodeIndex];
    vantagePoint = this.items[itemIndex];

    // Distance between query &amp; the current vantage point
    d = this.distance(vantagePoint, query);

    if (d &lt;= radius)
      neighbors.push({distance: d, item: vantagePoint});

    leftIndex = this.data[nodeIndex + 2];
    rightIndex = this.data[nodeIndex + 3];

    // We are a leaf
    if (!leftIndex &amp;&amp; !rightIndex)
      continue;

    mu = this.data[nodeIndex + 1];

    if (d &lt; mu) {
      if (leftIndex &amp;&amp; d &lt; mu + radius)
        stack.push(leftIndex);
      if (rightIndex &amp;&amp; d &gt;= mu - radius) // Might not be necessary to test
        stack.push(rightIndex);
    }
    else {
      if (rightIndex &amp;&amp; d &gt;= mu - radius)
        stack.push(rightIndex);
      if (leftIndex &amp;&amp; d &lt; mu + radius) // Might not be necessary to test
        stack.push(leftIndex);
    }
  }

  return neighbors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mnemonist.comparators" id="apidoc.module.mnemonist.comparators">module mnemonist.comparators</a></h1>


    <h2>
        <a href="#apidoc.element.mnemonist.comparators.DEFAULT_COMPARATOR" id="apidoc.element.mnemonist.comparators.DEFAULT_COMPARATOR">
        function <span class="apidocSignatureSpan">mnemonist.comparators.</span>DEFAULT_COMPARATOR
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DEFAULT_COMPARATOR = function (a, b) {
  if (a &lt; b)
    return -1;
  if (a &gt; b)
    return 1;

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mnemonist.comparators.reverseComparator" id="apidoc.element.mnemonist.comparators.reverseComparator">
        function <span class="apidocSignatureSpan">mnemonist.comparators.</span>reverseComparator
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reverseComparator(comparator) {
  return function(a, b) {
    return comparator(b, a);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>